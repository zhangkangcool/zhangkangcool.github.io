<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../../../img/favicon.ico">
        <title>Llvm pdf pgo - My Docs</title>
        <link href="../../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../../../css/brands.min.css" rel="stylesheet">
        <link href="../../../../css/solid.min.css" rel="stylesheet">
        <link href="../../../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../../..">My Docs</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../get%20pgo%20info/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../../Remove/remove/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            
            <li class="nav-item" data-bs-level="1"><a href="#1-clang-pgo" class="nav-link">1. Clang PGO</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#2-multi-files-single-files" class="nav-link">2. 基于插桩的配置文件 Multi Files &amp; Single Files</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#3-example" class="nav-link">3 基于插桩的配置文件Example</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#4-context-sensitive-pgocspgo" class="nav-link">4 Context Sensitive PGO(CSPGO)</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#5" class="nav-link">5 基于采样的配置文件使用</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#6-code" class="nav-link">6 Code</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#7-some-options" class="nav-link">7 Some options</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#8-libanalysisinlinecostcpp" class="nav-link">8 ./lib/Analysis/InlineCost.cpp</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#9-an-example" class="nav-link">9 An example</a>
              <ul class="nav flex-column">
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<p>build clang &amp; compiler_rt on e1v</p>
<pre><code class="language-shell">cmake $HOME/llvm/llvm -DLLVM_TARGETS_TO_BUILD=PowerPC  -DCMAKE_INSTALL_PREFIX=$HOME/llvm/install -DLLVM_ENABLE_ASSERTIONS=On -DCMAKE_BUILD_TYPE=RELEASE -DLLVM_ENABLE_PROJECTS=&quot;clang;compiler-rt&quot;  -DCMAKE_C_COMPILER=/opt/at12.0/bin/gcc -DCMAKE_CXX_COMPILER=/opt/at12.0/bin/g++ ../llvm -DLLVM_BINUTILS_INCDIR=/gsa/tlbgsa/projects/x/xlcdl/shkzhang/p9_software/binutils/binutils/include

</code></pre>
<p>How to use llvm pdf:</p>
<pre><code class="language-shell">https://source.android.google.cn/devices/tech/perf/pgo
</code></pre>
<p>llvm-profdata tool:</p>
<pre><code class="language-shell">http://llvm.org/docs/CommandGuide/llvm-profdata.html
</code></pre>
<p>clang pgo official document:</p>
<pre><code class="language-shell">https://clang.llvm.org/docs/UsersManual.html#profile-guided-optimization
</code></pre>
<h4 id="how-the-spec-use-the-pgo">How the spec use the pgo</h4>
<p>link don't need <code>fprofile</code>, but when build, all file need <code>fprofile</code>.</p>
<pre><code class="language-shell">default=peak:
PASS1_OPTIMIZE = -fprofile-generate
PASS1_LDFLAGS  = -pie %{LINKER} -Wl,-q  -Wl,-rpath=%{BASE_DIR}/lib
fdo_post1      =  %{BASE_DIR}/bin/llvm-profdata merge default*.profraw -output default.profdata
PASS2_OPTIMIZE = -fprofile-use %{LTO_OPTION}
PASS2_LDFLAGS  = -pie %{LINKER} -Wl,-q  -Wl,-rpath=%{BASE_DIR}/lib
</code></pre>
<h1 id="1-clang-pgo">1. Clang PGO</h1>
<pre><code class="language-shell">https://www.jianshu.com/p/bd2fe89e2025
https://source.android.com/devices/tech/perf/pgo
</code></pre>
<h3 id="11">1.1 两种配置文件</h3>
<p>Clang 可以使用两类配置文件来执行配置文件引导的优化：</p>
<pre><code class="language-shell">- 基于插桩的配置文件(基于AST和基于LLVM IR两种，由clang/llvm自带)
从插桩的目标程序生成的。这些配置文件很详细，且会产生很高的运行时开销。
- 基于采样的配置文件(使用外部工具生成profile文件，如perf)
通常通过对硬件计数器进行采样生成。此类配置文件产生的运行时开销较低，并且无需对二进制文件进行任何插桩或修改即可收集。详细程度不如基于插桩的配置文件。
</code></pre>
<h5 id="_1">基于插桩的两种配置文件</h5>
<p>所有配置文件都应该从执行应用的典型行为的代表性工作负载生成。 Clang 同时
- 支持基于 AST(clang FE)的配置文件 (<code>-fprofile-instr-generate</code>, <code>-fprofile-instr-use</code>) 
- 基于 LLVM IR (<code>-fprofile-generate</code>, <code>-fprofile-use</code>) 配置文件。</p>
<h5 id="_2">基于采样的配置文件：</h5>
<p>必须使用外部<code>profile</code>工具，如<code>gnu perf</code>产生配置文件，然后转化成llvm可以识别的格式，再用<code>-fprofile-sample-use=pathname</code>命令对其进行使用。</p>
<h5 id="_3">不同</h5>
<pre><code class="language-shell">https://clang.llvm.org/docs/UsersManual.html#profile-guided-optimization
Differences Between Sampling and Instrumentation
</code></pre>
<p>Although both techniques are used for similar purposes, there are important differences between the two:</p>
<ul>
<li>Profile data generated with one cannot be used by the other, and there is no conversion tool that can convert one to the other. So, a profile generated via <code>-fprofile-instr-generate</code> must be used with <code>-fprofile-instr-use</code>. Similarly, sampling profiles generated by external profilers must be converted and used with <code>-fprofile-sample-use</code>.</li>
<li>插桩配置文件可用于code分析和优化</li>
<li>Sampling profiles can only be used for optimization. They cannot be used for code coverage analysis. Although it would be technically possible to use sampling profiles for code coverage, sample-based profiles are too coarse-grained for code coverage purposes; it would yield poor results. 采样配置文件通常只用于优化</li>
<li>采样配置文件必须由外部工具产生，并对其进行格式转化。</li>
</ul>
<h1 id="2-multi-files-single-files">2. 基于插桩的配置文件 Multi Files &amp; Single Files</h1>
<h3 id="21-get-the-prof-data-file">2.1 Get the prof data file.</h3>
<p>need <code>libclang-rt</code>, and link must use the -fprofile-instr-generate/-fprofle-generate</p>
<pre><code class="language-shell">TARGET = main
OBJ=cal.o ioput.o main.o
CFLAG= -O2
PDF= -fprofile-generate
#the dataraw file will in the dir default-dir.dataraw
#PDF= -fprofile-generate=default-dir.dataraw
#CFLAG= -fprofile-generate
LFLAG=
CC=clang
main:$(OBJ)
    $(CC) $(OBJ) -o $(TARGET) $(LFLAG) $(PDF)
%.o:%.c
    $(CC) -c $(CFLAG) $(PDF) $&lt;
clean:
    rm $(TARGET) *.o
</code></pre>
<p>Run the program</p>
<pre><code class="language-shell">./main &lt; input.txt
LLVM_PROFILE_FILE=&quot;code.profraw&quot; ./main &lt; input.txt
</code></pre>
<p>If you don't use <code>LLVM_PROFILE_FILE</code>,  then you will get <code>default_711218735311555632_0.profraw</code> or <code>code.profraw</code>.</p>
<h3 id="22-merge-show-data-file">2.2 Merge &amp; Show data file.</h3>
<h5 id="llvm-profdata-merge-options-filename">llvm-profdata merge [options] [filename…]</h5>
<pre><code class="language-shell">llvm-profdata merge foo.profraw bar.profdata baz.profraw -output= merge.profdata
llvm-profdata merge *.profraw -output=merged.profdata
</code></pre>
<p>Even you have one one profdata file, you must use the merge command, or you will get below error:</p>
<pre><code class="language-shell">error: Could not read profile default_2461475265565158006_0.profraw: Invalid
      instrumentation profile data (bad magic)
1 error generated.
</code></pre>
<h5 id="llvm-profdata-show-options-filename-youd-better-use-show-after-use-merge">llvm-profdata show [options] [filename], you'd better use <code>show</code> after use <code>merge</code>.</h5>
<pre><code class="language-shell">llvm-profdata show -help
llvm-profdata show --help-list-hidden
llvm-profdata show -all-functions defult*.profraw

                  - Sample profile

可统计出热点函数的BB调用次数
 --text                                            - Show instr profile data in text dump 
 llvm-profdata show default.profdata --text -all-functions -o text.log

 筛选最热的BB
 --topn=&lt;uint&gt;                                     - Show the list of functions with the largest internal counts
 llvm-profdata show default.profdata  -all-functions --topn=10 -o topn.log
</code></pre>
<h3 id="23-use-the-prof-file">2.3 Use the prof file:</h3>
<p><code>default</code> is the file after we use <code>merge</code>.</p>
<pre><code class="language-shell">TARGET = main
OBJ=cal.o ioput.o main.o
CFLAG= -O2
PDF= -fprofile-use=merge.profraw
#CFLAG= -fprofile-generate
LFLAG=
CC=clang
main:$(OBJ)
    $(CC) $(OBJ) -o $(TARGET) $(LFLAG) $(PDF)
%.o:%.c
#   $(CC) -c $(CFLAG) $(PDF) $&lt;
    $(CC) -c $(CFLAG) $&lt;
clean:
    rm $(TARGET) *.o
</code></pre>
<h3 id="24-single-file-example">2.4 single file example</h3>
<ul>
<li>build</li>
</ul>
<pre><code class="language-shell">clang -O3 bintree.c -fprofile-generate -o bintree
</code></pre>
<ul>
<li>run</li>
</ul>
<pre><code class="language-shell">./bintree &lt; input.txt
</code></pre>
<ul>
<li>merge(transfter the format which llvm expects)</li>
</ul>
<pre><code class="language-shell">llvm-profdata merge -output=merge.profraw default_2461475265565158006_0.profraw
</code></pre>
<ul>
<li>use</li>
</ul>
<pre><code class="language-shell">clang -O3 bintree.c -fprofile-use=merge.profraw -mllvm -debug
</code></pre>
<pre><code class="language-shell">
Clang同时支持:
- 基于AST的（-fprofile-instr-generate）
- 基于LLVM IR的（-fprofile-generate).



# Options
./clang/lib/CodeGen/BackendUtil.cpp
</code></pre>
<p>-fdebug-info-for-profiling</p>
<h1 id="3-example">3 基于插桩的配置文件Example</h1>
<pre><code class="language-shell">Has some error in these blog.
https://cmdlinelinux.blogspot.com/2018/04/profiling-c-code-with-clang-using.html
</code></pre>
<h4 id="31-test-code">3.1 test code</h4>
<p>test.c</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define CTR 10

int
main()
{
    int i, j, k;
    for(i=0; i &lt; CTR; ++i) {
        printf(&quot;3: %d&quot;, i);
    }
    for(i=0; i &lt; CTR*10; ++i) {
        printf(&quot;3: %d&quot;, i);
    }
    for(i=0; i &lt; CTR*100; ++i) {
        printf(&quot;3: %d&quot;, i);
    }
    //  exit(0);
    return 0;
}
</code></pre>
<h4 id="32-build">3.2 build</h4>
<p>Notice that If you want use <code>-fconverage-mapping</code>, you must use <code>fprofile-instr-generate</code>, you can not use <code>fprofile-generate</code>.</p>
<pre><code class="language-shell">clang -O3 -fprofile-instr-generate  test.c -fcoverage-mapping -o test
</code></pre>
<h4 id="33-run">3.3 Run</h4>
<pre><code class="language-shell">./test
</code></pre>
<p>You will get default.profraw</p>
<h4 id="34-merge">3.4 merge</h4>
<pre><code class="language-shell">llvm-profdata merge -output=merge.profraw default.profraw
</code></pre>
<h4 id="35-view-the-result">3.5 View the result</h4>
<ul>
<li>Use <code>llvm-profdata show</code>:</li>
</ul>
<pre><code class="language-shell">llvm-profdata show -all-functions -counts -ic-targets merge.profraw
</code></pre>
<p>Output will look like:</p>
<pre><code class="language-shell">  1 Counters:
  2   main:
  3     Hash: 0x0000000000004104
  4     Counters: 4
  5     Function count: 1
  6     Indirect Call Site Count: 0
  7     Block counts: [10, 100, 1000]
  8     Indirect Target Results:
  9 Functions shown: 1
 10 Total functions: 1
 11 Maximum function count: 1
 12 Maximum internal block count: 1000
</code></pre>
<ul>
<li>Use <code>llvm-conv show</code>:</li>
</ul>
<pre><code class="language-shell">llvm-cov show a.out -instr-profile=merge.profraw
</code></pre>
<p>Output will look like:
So you easy to find the hot spot.</p>
<pre><code class="language-shell">Count|line#| source code
       |    1|#include &lt;stdio.h&gt;
       |    2|#include &lt;stdlib.h&gt;
  1.11k|    3|#define CTR 10
       |    4|
       |    5|int
       |    6|main()
      1|    7|{
      1|    8|    int i, j, k;
     11|    9|    for(i=0; i &lt; CTR; ++i) {
     10|   10|        printf(&quot;3: %d&quot;, i);
     10|   11|    }
    101|   12|    for(i=0; i &lt; CTR*10; ++i) {
    100|   13|        printf(&quot;3: %d&quot;, i);
    100|   14|    }
  1.00k|   15|    for(i=0; i &lt; CTR*100; ++i) {
  1.00k|   16|        printf(&quot;3: %d&quot;, i);
  1.00k|   17|    }
      1|   18|    //  exit(0);
      1|   19|    return 0;

      1|   20|}
</code></pre>
<p>Notice that the postion of <code>count</code> and <code>line</code> may be changed.</p>
<h1 id="4-context-sensitive-pgocspgo">4 Context Sensitive PGO(CSPGO)</h1>
<pre><code class="language-shell">https://reviews.llvm.org/D54175
https://reviews.llvm.org/rL354930
</code></pre>
<h3 id="41-pgo-cspgo">4.1 PGO &amp; CSPGO</h3>
<p>当前PGO配置文件计数对上下文不敏感.对于所有调用站点，内联函数的分支概率保持不变，并且它们可能与实际的分支概率非常不同。这些次优配置文件可以极大地影响一些下游优化，特别是对于机器基本块布局优化。</p>
<p>在这个补丁中，我们建议使用post-inline PGO插装/use pass，我们称之为上下文敏感的PGO (CSPGO)。对于想要获得最好性能的用户，他们可以在常规PGO的基础上进行第二轮PGO乐器/使用。它们将有两组配置文件计数。第一个pass配置文件将主要用于内联、间接调用提升和CGSCC简化pass优化。第二个pass配置文件用于后内联优化和代码生成优化。</p>
<ul>
<li>当前PGO是在inline之前做的。</li>
<li>CSPGO是在post-inline后做的。<code>-fprofile-use=pass1.profdata -fcs-profile-generate</code></li>
</ul>
<h3 id="42-how-to-use-cspgo">4.2 How to use CSPGO</h3>
<p>Regular PGO instrumentation and generate pass1 profile.</p>
<pre><code class="language-shell">clang -O2 -fprofile-generate source.c -o gen
./gen
llvm-profdata merge default.*profraw -o pass1.profdata
</code></pre>
<p>CSPGO instrumentation.</p>
<pre><code class="language-shell">clang -O2 -fprofile-use=pass1.profdata -fcs-profile-generate -o gen2
./gen2
</code></pre>
<p>Merge two sets of profiles</p>
<pre><code class="language-shell">llvm-profdata merge default.*profraw pass1.profdata -o profile.profdata
</code></pre>
<p>Use the combined profile. Pass manager will invoke two PGO use passes.</p>
<pre><code>clang -O2 -fprofile-use=profile.profdata -o use
</code></pre>
<p>第一次使用<code>-fprofile-use=pass1.profdata -fcs-profile-generate</code>，第二次使用<code>-fprofile-use=pass1.profdata</code>。</p>
<h1 id="5">5 基于采样的配置文件使用</h1>
<p>Sampling profilers are used to collect runtime information, such as hardware counters, while your application executes. They are typically very efficient and do not incur a large runtime overhead. The sample data collected by the profiler can be used during compilation to determine what the most executed areas of the code are.</p>
<p>Using the data from a sample profiler requires some changes in the way a program is built. Before the compiler can use profiling information, the code needs to execute under the profiler. The following is the usual build cycle when using sample profilers for optimization:</p>
<ul>
<li>Build the code with source line table information. You can use all the usual build flags that you always build your application with. The only requirement is that you add -gline-tables-only or -g to the command line. This is important for the profiler to be able to map instructions back to source line locations.</li>
</ul>
<pre><code class="language-shell">$ clang++ -O2 -gline-tables-only code.cc -o code
</code></pre>
<ul>
<li>Run the executable under a sampling profiler. The specific profiler you use does not really matter, as long as its output can be converted into the format that the LLVM optimizer understands. Currently, there exists a conversion tool for the Linux Perf profiler (https://perf.wiki.kernel.org/), so these examples assume that you are using Linux Perf to profile your code.</li>
</ul>
<pre><code class="language-shell">$ perf record -b ./code
</code></pre>
<p>Note the use of the -b flag. This tells Perf to use the Last Branch Record (LBR) to record call chains. While this is not strictly required, it provides better call information, which improves the accuracy of the profile data.
- Convert the collected profile data to LLVM’s sample profile format. This is currently supported via the AutoFDO converter create_llvm_prof. It is available at https://github.com/google/autofdo. Once built and installed, you can convert the perf.data file to LLVM using the command:</p>
<pre><code class="language-shell">$ create_llvm_prof --binary=./code --out=code.prof
</code></pre>
<p>This will read perf.data and the binary file ./code and emit the profile data in code.prof. Note that if you ran perf without the -b flag, you need to use <code>--use_lbr=false when calling create_llvm_prof</code>.</p>
<ul>
<li>Build the code again using the collected profile. This step feeds the profile back to the optimizers. This should result in a binary that executes faster than the original one. Note that you are not required to build the code with the exact same arguments that you used in the first step. The only requirement is that you build the code with -gline-tables-only and -fprofile-sample-use.</li>
</ul>
<pre><code class="language-shell">    $ clang++ -O2 -gline-tables-only -fprofile-sample-use=code.prof code.cc -o code
</code></pre>
<h1 id="6-code">6 Code</h1>
<pre><code class="language-shell">lib/Transforms/Instrumentation/PGOInstrumentation.cpp
</code></pre>
<h1 id="7-some-options">7 Some options</h1>
<h3 id="1-print-machine-bfi">1 -print-machine-bfi</h3>
<p>Print the machine block frequency info.</p>
<pre><code class="language-shell">llc ctrloop-shortLoops.ll -print-machine-bfi

block-frequency-info: testTripCount2NonSmallLoop
 - BB0[entry]: float = 1.0, int = 8
 - BB1[for.body]: float = 32.0, int = 255
 - BB2[if.then]: float = 20.0, int = 159
 - BB3[if.end]: float = 32.0, int = 255
 - BB4[for.end]: float = 1.0, int = 8
</code></pre>
<h3 id="2-print-bfi">2 -print-bfi</h3>
<p>Print the block frequency info.</p>
<pre><code class="language-shell">llc ctrloop-shortLoops.ll -print-bfi

block-frequency-info: testTripCount2NonSmallLoop
 - entry: float = 1.0, int = 8
 - for.body: float = 32.0, int = 255
 - if.then: float = 20.0, int = 159
 - if.end: float = 32.0, int = 255
</code></pre>
<h1 id="8-libanalysisinlinecostcpp">8 ./lib/Analysis/InlineCost.cpp</h1>
<p>If you use the <code>fprofile-use</code> option, you can find the <code>Hot callee</code> in the debug info file.</p>
<p><code>Hot callee</code></p>
<h1 id="9-an-example">9 An example</h1>
<p><code>cat foo.c</code></p>
<pre><code class="language-cpp">struct parm {
  int *arr;
  int m;
  int n;
};
void foo(struct parm *arg) {
  struct parm localArg = *arg;
  int m = localArg.m;
  int *s = localArg.arr;
  int n = localArg.n;
  do{
    int k = n;
    do{
      s[++k] = k++;
      s[k++] = k;
      s[k++] = k;
      s[k] = k;
      s[--k] = k--;
      s[k--] = k;
      s[--k] = k;
    }while(k--);
  } while(m--);

  s[n]=0;
}
</code></pre>
<p>cat main.c</p>
<pre><code class="language-cpp">struct parm {
  int *arr;
  int m;
  int n;
};
void foo(struct parm*);
int main() {
  int a[5000];
  struct parm arg = {a, 2000000000, 5};
  foo(&amp;arg);
  return 0;
}
</code></pre>
<p><code>pgo.ksh</code></p>
<pre><code class="language-shell">set -x
# profile-generate
rm t t.* t_* *.o *.s *.profraw *.profdata
clang -c main.c -O -fprofile-generate
clang -S foo.c -O -fno-vectorize -mllvm -unroll-count=0 -fprofile-generate
clang -o t main.o foo.s -fprofile-generate
objdump -dr t &gt; t.dis
time -p ./t

# merge
llvm-profdata merge *.profraw -output=merge.profdata

# profile-use
clang -c main.c -O -fprofile-use=merge.profdata
clang -S foo.c -O -fno-vectorize -mllvm -unroll-count=0 -fprofile-use=merge.profdata
clang -o t_pgo main.o foo.s -fprofile-use=merge.profdata
objdump -dr t_pgo &gt; t_pgo.dis
time -p ./t_pgo
</code></pre>
<h3 id="another-case">Another Case</h3>
<pre><code class="language-c++">$ cat def.c 
int test(int a, int b) {
  return a &lt;= b ? a : -a;
}

$ cat use.c 
int test(int, int);
int main(int argc, const char **argv) {
  int Ret = 0;
  for (int i = 0; i &lt; 1 &lt;&lt; 28; i += 1) {
    Ret += test(i, i - 1);
  }

  return Ret;
}

$ clang -O3 def.c use.c -fprofile-generate
$ ./a.out
$ llvm-profdata merge default_*.profraw -o default.profdata
$ clang -O3 def.c -fprofile-use -emit-llvm -S
$ grep '\!30' def.ll 
  %cond = select i1 %cmp, i32 %sub, i32 %a, !prof !30
!30 = !{!&quot;branch_weights&quot;, i32 1073741818, i32 6}
</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../../js/base.js"></script>
        <script src="../../../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
