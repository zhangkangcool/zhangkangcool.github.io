<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../../../../img/favicon.ico">
        <title>智能指针 - My Docs</title>
        <link href="../../../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../../../../css/brands.min.css" rel="stylesheet">
        <link href="../../../../../css/solid.min.css" rel="stylesheet">
        <link href="../../../../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../../../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../../../..">My Docs</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../../%E8%99%9A%E8%A1%A8%E8%99%9A%E6%8C%87%E9%92%88/C%2B%2B%E8%99%9A%E8%A1%A8%E5%9C%B0%E5%9D%80%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80%E6%89%93%E5%8D%B0/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#c11" class="nav-link">详解C++11智能指针</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#_1" class="nav-link">前言</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#c11_1" class="nav-link">C++11智能指针介绍</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_2" class="nav-link">为什么要使用智能指针</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#auto_ptr" class="nav-link">auto_ptr</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#unique_ptr" class="nav-link">unique_ptr</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#shared_ptr" class="nav-link">shared_ptr</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#weak_ptr" class="nav-link">weak_ptr</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#share_ptrweak_ptr" class="nav-link">share_ptr和weak_ptr的核心实现</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<p>https://www.cnblogs.com/WindSun/p/11444429.html</p>
<h1 id="c11"><a href="https://www.cnblogs.com/WindSun/p/11444429.html">详解C++11智能指针</a></h1>
<h2 id="_1">前言</h2>
<p>C++里面的四个智能指针: auto_ptr, unique_ptr,shared_ptr, weak_ptr 其中后三个是C++11支持，并且第一个已经被C++11弃用。</p>
<h2 id="c11_1">C++11智能指针介绍</h2>
<p>智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。</p>
<h2 id="_2">为什么要使用智能指针</h2>
<p>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针是一个类，当超出了类的实例对象的作用域时，会自动调用对象的析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p>
<h2 id="auto_ptr">auto_ptr</h2>
<p>（C++98的方案，C++11已经抛弃）采用所有权模式。</p>
<pre><code class="language-cpp">auto_ptr&lt;string&gt; p1 (new string (&quot;I reigned lonely as a cloud.&quot;)); 
auto_ptr&lt;string&gt; p2; 
p2 = p1; //auto_ptr不会报错.
</code></pre>
<p>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！</p>
<h2 id="unique_ptr">unique_ptr</h2>
<p>（替换auto_ptr）unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</p>
<p>采用所有权模式，还是上面那个例子</p>
<pre><code class="language-cpp">unique_ptr&lt;string&gt; p3 (new string (&quot;auto&quot;));   //#4
unique_ptr&lt;string&gt; p4；                       //#5
p4 = p3;//此时会报错！！
</code></pre>
<p>编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。尝试复制p3时会编译期出错，而auto_ptr能通过编译期从而在运行期埋下出错的隐患。因此，unique_ptr比auto_ptr更安全。</p>
<p>另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p>
<pre><code class="language-cpp">unique_ptr&lt;string&gt; pu1(new string (&quot;hello world&quot;)); 
unique_ptr&lt;string&gt; pu2; 
pu2 = pu1;                                      // #1 不允许
unique_ptr&lt;string&gt; pu3; 
pu3 = unique_ptr&lt;string&gt;(new string (&quot;You&quot;));   // #2 允许
</code></pre>
<p>其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。</p>
<p><strong>注：</strong>如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。尽管转移所有权后 还是有可能出现原有指针调用（调用就崩溃）的情况。但是这个语法能强调你是在转移所有权，让你清晰的知道自己在做什么，从而不乱调用原有指针。</p>
<p>（<strong>额外：</strong>boost库的boost::scoped_ptr也是一个独占性智能指针，但是它不允许转移所有权，从始而终都只对一个资源负责，它更安全谨慎，但是应用的范围也更狭窄。）</p>
<p>例如：</p>
<pre><code class="language-cpp">unique_ptr&lt;string&gt; ps1, ps2;
ps1 = demo(&quot;hello&quot;);
ps2 = move(ps1);
ps1 = demo(&quot;alexia&quot;);
cout &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; endl;
</code></pre>
<h2 id="shared_ptr">shared_ptr</h2>
<p>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p>
<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>
<p>成员函数：</p>
<p>use_count 返回引用计数的个数</p>
<p>unique 返回是否是独占所有权( use_count 为 1)</p>
<p>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)</p>
<p>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</p>
<p>get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如</p>
<pre><code class="language-cpp">shared_ptr&lt;int&gt; sp(new int(1)); 
</code></pre>
<p>sp 与 sp.get()是等价的。</p>
<p>share_ptr的简单例子：</p>
<pre><code class="language-cpp">int main()
{
    string *s1 = new string(&quot;s1&quot;);

    shared_ptr&lt;string&gt; ps1(s1);
    shared_ptr&lt;string&gt; ps2;
    ps2 = ps1;

    cout &lt;&lt; ps1.use_count()&lt;&lt;endl;  //2
    cout&lt;&lt;ps2.use_count()&lt;&lt;endl;    //2
    cout &lt;&lt; ps1.unique()&lt;&lt;endl; //0

    string *s3 = new string(&quot;s3&quot;);
    shared_ptr&lt;string&gt; ps3(s3);

    cout &lt;&lt; (ps1.get()) &lt;&lt; endl;    //033AEB48
    cout &lt;&lt; ps3.get() &lt;&lt; endl;  //033B2C50
    swap(ps1, ps3); //交换所拥有的对象
    cout &lt;&lt; (ps1.get())&lt;&lt;endl;  //033B2C50
    cout &lt;&lt; ps3.get() &lt;&lt; endl;  //033AEB48

    cout &lt;&lt; ps1.use_count()&lt;&lt;endl;  //1
    cout &lt;&lt; ps2.use_count() &lt;&lt; endl;    //2
    ps2 = ps1;
    cout &lt;&lt; ps1.use_count()&lt;&lt;endl;  //2
    cout &lt;&lt; ps2.use_count() &lt;&lt; endl;    //2
    ps1.reset();    //放弃ps1的拥有权，引用计数的减少
    cout &lt;&lt; ps1.use_count()&lt;&lt;endl;  //0
    cout &lt;&lt; ps2.use_count()&lt;&lt;endl;  //1
}
</code></pre>
<h2 id="weak_ptr">weak_ptr</h2>
<p>share_ptr虽然已经很好用了，但是有一点share_ptr智能指针还是有内存泄露的情况，当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。</p>
<p>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的shared_ptr， weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p>
<pre><code class="language-cpp">class B;    //声明
class A
{
public:
    shared_ptr&lt;B&gt; pb_;
    ~A()
    {
        cout &lt;&lt; &quot;A delete\n&quot;;
    }
};

class B
{
public:
    shared_ptr&lt;A&gt; pa_;
    ~B()
    {
        cout &lt;&lt; &quot;B delete\n&quot;;
    }
};

void fun()
{
    shared_ptr&lt;B&gt; pb(new B());
    shared_ptr&lt;A&gt; pa(new A());
    cout &lt;&lt; pb.use_count() &lt;&lt; endl; //1
    cout &lt;&lt; pa.use_count() &lt;&lt; endl; //1
    pb-&gt;pa_ = pa;
    pa-&gt;pb_ = pb;
    cout &lt;&lt; pb.use_count() &lt;&lt; endl; //2
    cout &lt;&lt; pa.use_count() &lt;&lt; endl; //2
}

int main()
{
    fun();
    return 0;
}
</code></pre>
<p>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减1，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A、B的析构函数没有被调用）运行结果没有输出析构函数的内容，造成内存泄露。如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_，改为weak_ptr pb_ ，运行结果如下：</p>
<pre><code class="language-cpp">1
1
1
2
B delete
A delete
</code></pre>
<p>这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减1，同时pa析构时使A的计数减1，那么A的计数为0，A得到释放。</p>
<p>注意：我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print()，我们不能这样访问，pa-&gt;pb_-&gt;print()，因为pb_是一个weak_ptr，应该先把它转化为shared_ptr，如：</p>
<pre><code class="language-cpp">shared_ptr&lt;B&gt; p = pa-&gt;pb_.lock();
p-&gt;print();
</code></pre>
<p>weak_ptr 没有重载*和-&gt;但可以使用 lock 获得一个可用的 shared_ptr 对象. 注意, weak_ptr 在使用前需要检查合法性.</p>
<p>expired 用于检测所管理的对象是否已经释放, 如果已经释放, 返回 true; 否则返回 false.</p>
<p>lock 用于获取所管理的对象的强引用(shared_ptr). 如果 expired 为 true, 返回一个空的 shared_ptr; 否则返回一个 shared_ptr, 其内部对象指向与 weak_ptr 相同.</p>
<p>use_count 返回与 shared_ptr 共享的对象的引用计数.</p>
<p>reset 将 weak_ptr 置空.</p>
<p>weak_ptr 支持拷贝或赋值, 但不会影响对应的 shared_ptr 内部对象的计数.</p>
<h2 id="share_ptrweak_ptr">share_ptr和weak_ptr的核心实现</h2>
<p>weakptr的作为弱引用指针，其实现依赖于counter的计数器类和share_ptr的赋值，构造，所以先把counter和share_ptr简单实现</p>
<h3 id="counter">Counter简单实现</h3>
<pre><code class="language-cpp">class Counter
{
public:
    Counter() : s(0), w(0){};
    int s;  //share_ptr的引用计数
    int w;  //weak_ptr的引用计数
};
</code></pre>
<p>counter对象的目地就是用来申请一个块内存来存引用基数，s是share_ptr的引用计数，w是weak_ptr的引用计数，当w为0时，删除Counter对象。</p>
<h3 id="share_ptr">share_ptr的简单实现</h3>
<pre><code class="language-cpp">template &lt;class T&gt;
class WeakPtr; //为了用weak_ptr的lock()，来生成share_ptr用，需要拷贝构造用

template &lt;class T&gt;
class SharePtr
{
public:
    SharePtr(T *p = 0) : _ptr(p)
    {
        cnt = new Counter();
        if (p)
            cnt-&gt;s = 1;
        cout &lt;&lt; &quot;in construct &quot; &lt;&lt; cnt-&gt;s &lt;&lt; endl;
    }
    ~SharePtr()
    {
        release();
    }

    SharePtr(SharePtr&lt;T&gt; const &amp;s)
    {
        cout &lt;&lt; &quot;in copy con&quot; &lt;&lt; endl;
        _ptr = s._ptr;
        (s.cnt)-&gt;s++;
        cout &lt;&lt; &quot;copy construct&quot; &lt;&lt; (s.cnt)-&gt;s &lt;&lt; endl;
        cnt = s.cnt;
    }
    SharePtr(WeakPtr&lt;T&gt; const &amp;w) //为了用weak_ptr的lock()，来生成share_ptr用，需要拷贝构造用
    {
        cout &lt;&lt; &quot;in w copy con &quot; &lt;&lt; endl;
        _ptr = w._ptr;
        (w.cnt)-&gt;s++;
        cout &lt;&lt; &quot;copy w  construct&quot; &lt;&lt; (w.cnt)-&gt;s &lt;&lt; endl;
        cnt = w.cnt;
    }
    SharePtr&lt;T&gt; &amp;operator=(SharePtr&lt;T&gt; &amp;s)
    {
        if (this != &amp;s)
        {
            release();
            (s.cnt)-&gt;s++;
            cout &lt;&lt; &quot;assign construct &quot; &lt;&lt; (s.cnt)-&gt;s &lt;&lt; endl;
            cnt = s.cnt;
            _ptr = s._ptr;
        }
        return *this;
    }
    T &amp;operator*()
    {
        return *_ptr;
    }
    T *operator-&gt;()
    {
        return _ptr;
    }
    friend class WeakPtr&lt;T&gt;; //方便weak_ptr与share_ptr设置引用计数和赋值

protected:
    void release()
    {
        cnt-&gt;s--;
        cout &lt;&lt; &quot;release &quot; &lt;&lt; cnt-&gt;s &lt;&lt; endl;
        if (cnt-&gt;s &lt; 1)
        {
            delete _ptr;
            if (cnt-&gt;w &lt; 1)
            {
                delete cnt;
                cnt = NULL;
            }
        }
    }

private:
    T *_ptr;
    Counter *cnt;
};
</code></pre>
<p>share_ptr的给出的函数接口为：构造，拷贝构造，赋值，解引用，通过release来在引用计数为0的时候删除_ptr和cnt的内存。</p>
<h3 id="weak_ptr_1">weak_ptr简单实现</h3>
<pre><code class="language-cpp">template &lt;class T&gt;
class WeakPtr
{
public: //给出默认构造和拷贝构造，其中拷贝构造不能有从原始指针进行构造
    WeakPtr()
    {
        _ptr = 0;
        cnt = 0;
    }
    WeakPtr(SharePtr&lt;T&gt; &amp;s) : _ptr(s._ptr), cnt(s.cnt)
    {
        cout &lt;&lt; &quot;w con s&quot; &lt;&lt; endl;
        cnt-&gt;w++;
    }
    WeakPtr(WeakPtr&lt;T&gt; &amp;w) : _ptr(w._ptr), cnt(w.cnt)
    {
        cnt-&gt;w++;
    }
    ~WeakPtr()
    {
        release();
    }
    WeakPtr&lt;T&gt; &amp;operator=(WeakPtr&lt;T&gt; &amp;w)
    {
        if (this != &amp;w)
        {
            release();
            cnt = w.cnt;
            cnt-&gt;w++;
            _ptr = w._ptr;
        }
        return *this;
    }
    WeakPtr&lt;T&gt; &amp;operator=(SharePtr&lt;T&gt; &amp;s)
    {
        cout &lt;&lt; &quot;w = s&quot; &lt;&lt; endl;
        release();
        cnt = s.cnt;
        cnt-&gt;w++;
        _ptr = s._ptr;
        return *this;
    }
    SharePtr&lt;T&gt; lock()
    {
        return SharePtr&lt;T&gt;(*this);
    }
    bool expired()
    {
        if (cnt)
        {
            if (cnt-&gt;s &gt; 0)
            {
                cout &lt;&lt; &quot;empty&quot; &lt;&lt; cnt-&gt;s &lt;&lt; endl;
                return false;
            }
        }
        return true;
    }
    friend class SharePtr&lt;T&gt;; //方便weak_ptr与share_ptr设置引用计数和赋值

protected:
    void release()
    {
        if (cnt)
        {
            cnt-&gt;w--;
            cout &lt;&lt; &quot;weakptr release&quot; &lt;&lt; cnt-&gt;w &lt;&lt; endl;
            if (cnt-&gt;w &lt; 1 &amp;&amp; cnt-&gt;s &lt; 1)
            {
                //delete cnt;
                cnt = NULL;
            }
        }
    }

private:
    T *_ptr;
    Counter *cnt;
};
</code></pre>
<p>weak_ptr一般通过share_ptr来构造，通过expired函数检查原始指针是否为空，lock来转化为share_ptr。</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../../../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../../../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../../../js/base.js"></script>
        <script src="../../../../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
