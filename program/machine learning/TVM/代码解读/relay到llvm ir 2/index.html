<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../../../../img/favicon.ico">
        <title>Relay到llvm ir 2 - My Docs</title>
        <link href="../../../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../../../../css/brands.min.css" rel="stylesheet">
        <link href="../../../../../css/solid.min.css" rel="stylesheet">
        <link href="../../../../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../../../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../../../..">My Docs</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../relay%E5%88%B0llvm%20ir%201/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../relay%E5%88%B0llvm%20ir%203/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<p>为了方便，再次插入第一段的代码:</p>
<pre><code class="language-cpp">  void BuildRelay(IRModule relay_module,
                  const std::unordered_map&lt;std::string, tvm::runtime::NDArray&gt;&amp; params) {
    // Relay IRModule -&gt; IRModule optimizations.
    relay_module = Optimize(relay_module, targets_, params);
    // Get the updated function.
    auto func = Downcast&lt;Function&gt;(relay_module-&gt;Lookup(&quot;main&quot;));

    // Generate code for the updated function.
    graph_codegen_ = std::unique_ptr&lt;GraphCodegen&gt;(new GraphCodegen());
    graph_codegen_-&gt;Init(nullptr, targets_);
    graph_codegen_-&gt;Codegen(func);
    /* ... */
 }
</code></pre>
<p>可以看到代码生成是从relay模块的入口函数"main"开始的，主要工作由graph_codegen_来完成，故必须先整明白graph_codegen_是个什么东西。</p>
<p>GraphCodegen结构体定义在<strong>src/relay/backend/<a href="https://link.zhihu.com/?target=http%3A//build_module.cc%3A58">http://build_module.cc:58</a></strong>。它里边有一个成员对象mod为<strong>tvm::runtime::Module</strong>类的实例，下边展示的是GraphCodegen结构体的部分代码，省去了暂时不会用到的函数。</p>
<pre><code class="language-text">struct GraphCodegen {
 public:
  GraphCodegen() {
    auto pf = GetPackedFunc(&quot;relay.build_module._GraphRuntimeCodegen&quot;);
    mod = (*pf)();
  }
  ~GraphCodegen() {}

  void Init(runtime::Module* m, TargetsMap targets) { CallFunc(&quot;init&quot;, m, targets); }

  void Codegen(const Function&amp; func) { CallFunc(&quot;codegen&quot;, func); }

 protected:
  tvm::runtime::Module mod;

  template &lt;typename R, typename... Args&gt;
  R CallFunc(const std::string&amp; name, Args... args) {
    auto pf = mod.GetFunction(name, false);
    return pf(std::forward&lt;Args&gt;(args)...);
  }
  template &lt;typename... Args&gt;
  void CallFunc(const std::string&amp; name, Args... args) {
    auto pf = mod.GetFunction(name, false);
    pf(std::forward&lt;Args&gt;(args)...);
    return;
  }
}
</code></pre>
<p>它的方法是经过转发实际调用了<strong>GraphRuntimeCodegenModule</strong>类的方法，这两个类的桥梁就是mod成员对象和CallFunction方法, 初始化函数中的pf实际指向的是CreateGraph-CodegenMod函数，mod被初始化为GraphRuntimeCodegenModule类的对象。下面是桥接的代码(<strong>src/relay/backend/graph_runtime*_*<a href="https://link.zhihu.com/?target=http%3A//codegen.cc">http://codegen.cc</a>)</strong>:</p>
<pre><code class="language-text">runtime::Module CreateGraphCodegenMod() {
  auto ptr = make_object&lt;GraphRuntimeCodegenModule&gt;();
  return runtime::Module(ptr);
}

TVM_REGISTER_GLOBAL(&quot;relay.build_module._GraphRuntimeCodegen&quot;)
    .set_body([](TVMArgs args, TVMRetValue* rv) { *rv = CreateGraphCodegenMod(); });
</code></pre>
<p>很显然现在得把关注点聚焦在<strong>GraphRuntimeCodegenModule</strong>(<strong>graph_runtime*_*<a href="https://link.zhihu.com/?target=http%3A//cod-egen.cc%3A553">http://cod-egen.cc:553</a></strong>)类上，这个类的初始化函数什么都没干。</p>
<p>回忆起BuildRelay中，分别调用了init和codegen方法，现在来一探究竟。</p>
<p>插个题外话: 浏览TVM源码时我发现作者们似乎很喜欢用函数式编程的风格，让俺甚是喜欢，即便是用C++来做令俺有点看不太懂。不得不感慨，C++真是博大精深。</p>
<p>GraphRuntimeCodegenModule类中就只实现了GetFunction方法，除了init和codegen,其他的是getXXX方法，无关紧要。</p>
<pre><code class="language-text">virtual PackedFunc GetFunction(const std::string&amp; name, const ObjectPtr&lt;Object&gt;&amp; sptr_to_self) {
    if (name == &quot;init&quot;) {
      return PackedFunc([sptr_to_self, this](TVMArgs args, TVMRetValue* rv) {
        CHECK_EQ(args.num_args, 2) &lt;&lt; &quot;The expected of arguments are: &quot;
                                   &lt;&lt; &quot;runtime::Module mod and Map&lt;int, Target&gt; targets&quot;;
        void* mod = args[0];
        Map&lt;Integer, tvm::Target&gt; tmp = args[1];
        TargetsMap targets;
        for (const auto&amp; it : tmp) {
          auto dev_type = it.first.as&lt;tir::IntImmNode&gt;();
          CHECK(dev_type);
          targets[dev_type-&gt;value] = it.second;
        }
        codegen_ =
            std::make_shared&lt;GraphRuntimeCodegen&gt;(reinterpret_cast&lt;runtime::Module*&gt;(mod), targets);
      });
    } else if (name == &quot;codegen&quot;) {
      return PackedFunc([sptr_to_self, this](TVMArgs args, TVMRetValue* rv) {
        Function func = args[0];
        this-&gt;output_ = this-&gt;codegen_-&gt;Codegen(func);
      });
    } 
}
</code></pre>
<p>先看codegen, 它实际上是调用了codegen_成员的Codegen方法，而codegen_是在init中进行初始化的<strong>GraphRuntimeCodegen</strong>类实例。我暂时先把init中对targets的处理放在一旁，等到有需要的时候再回来研究研究。现在重点变成了GraphRuntimeCodegen类。</p>
<p>Ps: 从刚才到现在绕了点弯子, 接下来也会有点绕，先总结一下，我们目前的旅程是:</p>
<p>GraphCodegen-&gt; GraphRuntimeCodegenModule -&gt; GraphRuntimeCodegen</p>
<p>好了，开始研究GraphRuntimeCodegen(graph_runtime<em>_</em><a href="https://link.zhihu.com/?target=http%3A//codegen.cc%3A185">http://codegen.cc:185</a>)。初始化函数将成员对象compile_engine_初始化为CompileEngineImpl类实例, 注释说CompileEngineI-mpl的功能是"<strong>backend compilation engine for low level code generation</strong>", 目前不清楚它是用来生成ir还是机器码，我粗略地扫了一眼这个类的方法，感觉挺猛的。但是它现在不是俺的重点盯防对象，也许会在后边遇到它。回到GraphRuntimeCodegen中，先研究研究Codegen方法干了啥。</p>
<pre><code class="language-text">LoweredOutput Codegen(relay::Function func) {
    auto pf = GetPackedFunc(&quot;relay.backend.GraphPlanMemory&quot;);
    storage_device_map_ = (*pf)(func);
    // First we convert all the parameters into input nodes.
    for (auto param : func-&gt;params) {
      auto node_ptr = GraphInputNode::make_node_ptr(param-&gt;name_hint(), GraphAttrs());
      var_map_[param.get()] = AddNode(node_ptr, param);
    }
    heads_ = VisitExpr(func-&gt;body);
    std::ostringstream os;
    dmlc::JSONWriter writer(&amp;os);
    GetJSON(&amp;writer);
    LoweredOutput ret;
    ret.graph_json = os.str();
    ret.params = params_;

    for (auto&amp; kv : lowered_funcs_) {
      if (ret.lowered_funcs.count(kv.first) == 0) {
        ret.lowered_funcs.Set(kv.first, IRModule());
      }
      auto&amp; mod = ret.lowered_funcs[kv.first];
      mod-&gt;Update(kv.second);
      ret.lowered_funcs.Set(kv.first, mod);
    }
    ret.external_mods = compile_engine_-&gt;LowerExternalFunctions();
    return ret;
}
</code></pre>
<p>写项目改过点clang和llvm代码，一看到老熟人VisitExpr俺就乐了，想都不用想这肯定是重点观察对象。但是，还是先看看它怎么把输入转变为节点的吧，也就是第一行注释底下那个for循环干的事，循环中第一句根据每个参数创建了GraphInputNode实例，第二句调用AddNode把先前创建的节点加入到图中，一个个来看。</p>
<p>GraphInputNode是个啥?</p>
<p>是<strong>GraphNode</strong>的子类，GraphNode代表现在要建的图中的节点，我搜了一下它似乎只有两个子类，GraphInputNode和GraphOpNode。</p>
<p>先来探究这个GraphNode类。</p>
<pre><code class="language-text">class GraphNode {
 public:
  GraphNode() {}
  virtual void Save(dmlc::JSONWriter* writer) const {}
  virtual void Load(dmlc::JSONReader* reader) {}
  virtual GraphNodeType Type() const { return kGraphNop; }
  virtual ~GraphNode() {}

 public:
  int num_outputs_{1};
  std::string name_;
  GraphAttrs attrs_;
};
</code></pre>
<p>一看到JSON相关的我就想起文档中说的可以把生成的图以json格式保存下来，以后再读取，大概底层就是调用的各个节点的Save和Load来实现的吧，python代码长这样:</p>
<pre><code class="language-python">with open(temp.relpath(&quot;deploy_graph.json&quot;), &quot;w&quot;) as fo:
    fo.write(graph)
</code></pre>
<p>在进入它的子类之前，看看它本身有什么有趣的地方，我发现了GraphAttrs这个类型，它是一个别名:</p>
<pre><code class="language-text">using GraphAttrs = std::unordered_map&lt;std::string, dmlc::any&gt;;
</code></pre>
<p>实际上是一个map，键是字符串，值类型为any, 看注释说是和C++17的std::any兼容，我搜了一下C++17的这东西，可以充当任何类型单个值的类型安全的容器，顿时我对GraphAttrs的用途产生了强烈的好奇。</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../../../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../../../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../../../js/base.js"></script>
        <script src="../../../../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
